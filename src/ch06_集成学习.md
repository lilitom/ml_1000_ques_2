    [TOC]
  
# 6 集成学习方法

  
## 6.1 bagging

  
### 6.1.1 bagging和boosting区别

  Bagging：即自助法，无放回的采样，学习到多个基模型，然后进行融合。  
  Boosting是一族可以将弱分类器提升为强分类器的算法，首先基于初始数据集训练基模型，然后再根据基学习期的表现对样本分布进行调整，使得错误的样本得到较大的关注，基于调整后的数据训练模型，训练得到多个模型，然后将模型的结果加权即可。 
    区别如下： 
  Bagging和Boosting的区别：  
  1）样本选择上  
  Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。  
  Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。  
  2）样例权重  
  Bagging：使用均匀取样，每个样例的权重相等Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。  
  3）预测函数  
  Bagging：所有预测函数的权重相等。Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。  
  4）并行计算  
  Bagging：各个预测函数可以并行生成Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。  
    详细见：  
  https://zhuanlan.zhihu.com/p/81340270
    
### 6.1.2 为啥adboost不容易过拟合？

  在解决这个问题之前，我们需要先了解一下隐马科夫模型Adboost的定义是什么？Adaboost算法是一种提升方法，将多个弱分类器，组合成强分类器。AdaBoost，是英文”Adaptive Boosting“（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个弱分类器分错的样本的权值（样本对应的权值）会得到加强，权值更新后的样本再次被用来训练下一个新的弱分类器。在每轮训练中，用总体（样本总体）训练新的弱分类器，产生新的样本权值、该弱分类器的话语权，一直迭代直到达到预定的错误率或达到指定的最大迭代次数。
    对于过拟合问题，如今找到的能解释只有Margin理论能解释的还不错，这个理论是从泛化错误 < 训练Margin项 + 学习算法容量相关项到泛化错误 < 训练Margin项最小值 + 学习算法容量相关项进行发展，国内的一些学者 周志华 王立威 等也做了相关的研究。Margin理论讨论的主要是学习算法在训练样本上的信心.通过其他一些在variance-bias 分解实验中也观察到，AdaBoost不仅是减少了bias，同时也减少了variance，variance的减少往往与算法容量减少有关。有兴趣的小伙伴可以看一下参考文献。
    https://jeremykun.com/2015/09/21/the-boosting-margin-or-why-boosting-doesnt-overfit/
          
### 6.1.3 为什么随机森林的泛化能力较强？

  随机森林的泛化误差界与单个决策树的分类强度`$s$`成负相关，与决策树之间的相关性`$\rho$`成正相关，分类强度`$\rho$`越大且相关性`$s$`越小，泛化误差界越小，可以看到随机森林中的随机性可以保证`$\rho$`越小，如果每棵树的越大的话，泛化误差会收敛到一个small界，这个界当然越小越好，就是泛化误差越小。
    
### 6.1.4 解释下stacking技术？

  Stacking是通过一个元分类器或者元回归器来整合多个分类模型或回归模型的集成学习技术。基础模型利用整个训练集做训练，元模型将基础模型的特征作为特征进行训练。
        
### 6.1.5 为什么bagging减少方差

  当融合多棵树的结果的时候，最后的方差是
  ```math
  \rho \sigma^2 +(1-\rho)\frac{\sigma^2}{B}
  ```
  可以看到 `$\rho$`越小，`$B$`越大，方差越小  
  详细可以看  
  https://stats.stackexchange.com/questions/380023/how-can-we-explain-the-fact-that-bagging-reduces-the-variance-while-retaining-t  
  推导在
  https://zhuanlan.zhihu.com/p/373404605
    
### 6.1.6 什么场景下采用bagging集成方法

  学习算法不稳定：if small changes to the training set cause large changes in the learned classifier.（也就是说如果训练集稍微有所改变就会导致分类器性能比较大大变化那么我们可以采用bagging这种集成方法）If the learning algorithm is unstable, then Bagging almost always improves performance.(当学习算法不稳定的时候，Bagging这种方法通常可以改善模型的性能)
    详细见  
  https://zhuanlan.zhihu.com/p/81340270
    
### 6.1.7 bagging和dropout区别

  dropout训练与bagging训练不太一样，bagging的各个子模型之间是完全独立的，而在dropout里，这些参数是共享的。每个模型集成父神经网络参数的不同子集，参数共享使得在有限可用内存下表示指数级数量的模型变得可能，在bagging的情况下，每一个模型在其训练集上训练到收敛，而在dropout情况下，通常大部分的模型都没有显式的训练，因为父神经网络很大，大到宇宙毁灭都不可能采样完所有的网络，在每一个步骤中，我们训练一小部分网络，参数共享会使得剩余的网络也有好的参数设定。  
  详细见  
  https://zhuanlan.zhihu.com/p/149575988
    
### 6.1.8 bagging和boosting的区别

  1）样本选择上：  
  Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的.  
  Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化.而权值是根据上一轮的分类结果进行调整.  
  2）样例权重：  
  Bagging：使用均匀取样，每个样例的权重相等.  
  Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大.  
  **3）预测函数：**  
  Bagging：所有预测函数的权重相等.  
  Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重.  
  4）并行计算：  
  Bagging：各个预测函数可以并行生.   
  Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果.
    
### 6.1.9 为什么说bagging是减少variance，而boosting是减少bias?

  boosting是把许多弱的分类器组合成一个强的分类器。弱的分类器bias高，而强的分类器bias低，所以说boosting起到了降低bias的作用。variance不是boosting的主要考虑因素。bagging是对许多强（甚至过强）的分类器求平均。在这里，每个单独的分类器的bias都是低的，平均之后bias依然低；而每个单独的分类器都强到可能产生overfitting的程度，也就是variance高，求平均的操作起到的作用就是降低这个variance。
  
### 6.1.10 请从偏差和方差的角度解释bagging和boosting的原理

  偏差指的是算法的期望预测与真实值之间的偏差程度，反映了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。
    Bagging对样本重采样，对每一重采样得到的子样本集训练一个模型，最后取平均。由于子样本集的相似性以及使用的是同种模型，因此各模型有近似相等的bias和variance。由于`$E[\frac{{\sum {{X_i}} }}{n}] = E[{X_i}]$`，所以bagging后的bias和单个子模型的接近，一般来说不能显著降低bias。另一方面，若各子模型独立，则有`$Var[\frac{{\sum {{X_i}} }}{n}] = \frac{{Var[{X_i}]}}{n}$`，此时可以显著降低variance。若各子模型完全相同，则`$Var[\frac{{\sum {{X_i}} }}{n}] = Var[{X_i}]$`，此时不会降低variance。
    bagging方法得到的各子模型是有一定相关性的，属于上面两个极端状况的中间态，因此可以一定程度降低variance。
    boosting从优化角度来看，是用forward-stagewise这种贪心法去最小化损失函数,由于采取的是串行优化的策略，各子模型之间是强相关的，于是子模型之和并不能显著降低variance。所以说boosting主要还是靠降低bias来提升预测精度。
    
### 6.1.11 详细说明下决策数如何计算特征重要性的？

  对于简单的的决策数，sklearn中是使用基尼指数来计算的，也就是基尼不纯度，决策数首先要构造好后才可以计算特征重要性，当然，我们在构建数的过程中已近计算好了特征重要性的一些值，如基尼指数，最后我们得到特征重要性的话，就直接将基尼指数做些操作就可以了。在sklearn中，feature_importances_应当就是这个Gini importance，也是就
  ```
  N_t / N * (impurity - N_t_R / N_t * right_impurity
  - N_t_L / N_t * left_impurity)
  ```
    
### 6.1.12 softmax的这个小细节问题吗?

  在我们的softmax计算过程中会遇到上溢下溢的问题，这点我们可以从softmax的函数中看到。
  ```math
  f(x) = \frac{{\exp (x)}}{{\sum\limits_{i = 1}^k {\exp (x)} }}
  ```
  可以看到我们的分子和分母都是指数函数，当`$x$`取值过大时会导致数据溢出，当`$x$`都很小的时候，分母为0，举个例子，当x=[10000,5000,2000]的时候，超过了计算机所能存储的最大范围，就会发生溢出。当x=[-10000,-1000,-34343]的时候，分母很小很小，基本为0，导致计算结果为nan.
    那如何解决呢，只要将x进行变换就可以,将原数组变成x-max(x)。对于x=[10000,5000,2000]，则变成x=[0,-5000,-8000]，这样分母最少为1，分子不用说没问题也不会溢出。为啥减去一个max(x)就可以呢，我们看如下的公式：
  ```math
  \frac{{\exp (x - a)}}{{\sum\limits_{i = 1}^k {\exp (x - a)} }} = \frac{{\exp (x)\exp ( - a)}}{{\exp ( - a)\sum\limits_{i = 1}^k {\exp (x)} }}
  ```
  这样就可以啦。
      
### 6.1.13 adaboost为什么不容易过拟合？

  这里需要用到一个理论来说一下。
  Margin理论讨论的主要是学习算法在训练样本上的信心，学习算法的容量是不是随着训练轮数的增加而增加呢，其实并不一定，近来有工作表明，有差异的学习器的组合，能够起到正则化的作用，也就是减少学习算法容量（Diversity regularized ensemble pruning. ECML'12; On the Generalization Error Bounds of Neural Networks under Diversity-Inducing Mutual Angular Regularization）。在许多variance-bias 分解实验中也观察到，AdaBoost不仅是减少了bias，同时也减少了variance，variance的减少往往与算法容量减少有关。
    详细见  
  https://www.zhihu.com/question/41047671/answer/127832345
    
### 6.1.14 Random
  其实随机森林是可以用来做聚类的，对于没有标签的特征，随机森林通过生成数据来实现聚类。其主要的步骤如下：
    第一步：生成假冒数据和临时标签。
    我们先给原数据集增加一列，名叫“标签”，原生数据每一行的标签都是“1”。下面生成一些假数据，假数据的每一列都是从原生数据中根据其经验分布随机产生的，人工合成的数据的标签是“0”。举个例子，
    标签 身高 体重 年龄
    1 184 158 25
    1 170 162 37
    1 165 132 45
    1 110 78 9
    1 145 100 14
    1 ... ... ...
    上面是原生数据，下面我们开始制造虚假数据
    标签 身高 体重 年龄
    1 184 158 25
    1 170 162 37
    1 165 132 45
    1 110 78 9
    1 145 100 14
    1 ... ... ...
    0 170 100 9
    0 110 162 37
    0 165 158 14
    每行假数据的每一个元素都是从它所在的那一列中随机抽取的，列和列之间的抽取是独立的。这样一来，人工合成的假数据就破坏了原有数据的结构性。现在我们的数据集和标签就生成完了。
    第二步：用该数据集训练Random Forest并获得样本间的临近性(proximity)。
    假设原生样本有N行，我们再生成M个假数据。现在我们就有了带标签的样本之后就可以用它训练出一个Random Forest。Random Forest在训练的同时，可以返回样本之间的临近性(proximity，两个样本出现在树杈同一节点的频率越高，它们就越临近)。我们就有了一个(N+M)x(N+M)的临近矩阵（这是个对称矩阵）。把与假数据相关的M行、M列去掉，我们就得到了NxN的矩阵，矩阵的第i行第j列的数值就是原生数据中第i个样本和第j个样本之间的临近性。
    第三步：根据每个样本点两两之间的临近性来聚类。
    这个是最后一步，在其中可以用两两之间的临近性当做两两之间的距离，然后再利用常规的聚类算法，比如层次聚类法(Hierarchical clustering)，就可以完成对原样本的聚类。
      
### 6.1.15 组合弱学习器的算法？

  为了建立一个集成学习方法，我们首先要选择待聚合的基础模型。在大多数情况下（包括在众所周知的 bagging 和 boosting 方法中），我们会使用单一的基础学习算法，这样一来我们就有了以不同方式训练的同质弱学习器。这样得到的集成模型被称为「同质的」。然而，也有一些方法使用不同种类的基础学习算法：将一些异质的弱学习器组合成「异质集成模型」。很重要的一点是：我们对弱学习器的选择应该和我们聚合这些模型的方式相一致。如果我们选择具有低偏置高方差的基础模型，我们应该使用一种倾向于减小方差的聚合方法；而如果我们选择具有低方差高偏置的基础模型，我们应该使用一种倾向于减小偏置的聚合方法。
    bagging，该方法通常考虑的是同质弱学习器，相互独立地并行学习这些弱学习器，并按照某种确定性的平均过程将它们组合起来。boosting，该方法通常考虑的也是同质弱学习器。它以一种高度自适应的方法顺序地学习这些弱学习器（每个基础模型都依赖于前面的模型），并按照某种确定性的策略将它们组合起来。stacking，该方法通常考虑的是异质弱学习器，并行地学习它们，并通过训练一个「元模型」将它们组合起来，根据不同弱模型的预测结果输出一个最终的预测结果。
    详细见  
  https://zhuanlan.zhihu.com/p/65888174  